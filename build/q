[4mstrtol[24m(3)                                                                                                                                                                 Library Functions Manual                                                                                                                                                                 [4mstrtol[24m(3)

[1mNAME[0m
       strtol, strtoll, strtoq - convert a string to a long integer

[1mLIBRARY[0m
       Standard C library ([4mlibc[24m, [4m-lc[24m)

[1mSYNOPSIS[0m
       [1m#include <stdlib.h>[0m

       [1mlong strtol(const char *restrict [4m[22mnptr[24m[1m,[0m
                   [1mchar **_Nullable restrict [4m[22mendptr[24m[1m, int [4m[22mbase[24m[1m);[0m
       [1mlong long strtoll(const char *restrict [4m[22mnptr[24m[1m,[0m
                   [1mchar **_Nullable restrict [4m[22mendptr[24m[1m, int [4m[22mbase[24m[1m);[0m

   Feature Test Macro Requirements for glibc (see [1mfeature_test_macros[22m(7)):

       [1mstrtoll[22m():
           _ISOC99_SOURCE
               || /* glibc <= 2.19: */ _SVID_SOURCE || _BSD_SOURCE

[1mDESCRIPTION[0m
       The [1mstrtol[22m() function converts the initial part of the string in [4mnptr[24m to a long integer value according to the given [4mbase[24m, which must be between 2 and 36 inclusive, or be the special value 0.

       The  string  may  begin with an arbitrary amount of white space (as determined by [1misspace[22m(3)) followed by a single optional '+' or '-' sign.  If [4mbase[24m is zero or 16, the string may then include a "0x" or "0X" prefix, and the number will be read in base 16; otherwise, a zero [4mbase[24m is taken as 10 (decimal) unless the next character is '0', in which case it is
       taken as 8 (octal).

       The remainder of the string is converted to a [4mlong[24m value in the obvious manner, stopping at the first character which is not a valid digit in the given base.  (In bases above 10, the letter 'A' in either uppercase or lowercase represents 10, 'B' represents 11, and so forth, with 'Z' representing 35.)

       If [4mendptr[24m is not NULL, and the [4mbase[24m is supported, [1mstrtol[22m() stores the address of the first invalid character in [4m*endptr[24m.  If there were no digits at all, [1mstrtol[22m() stores the original value of [4mnptr[24m in [4m*endptr[24m (and returns 0).  In particular, if [4m*nptr[24m is not '\0' but [4m**endptr[24m is '\0' on return, the entire string is valid.

       The [1mstrtoll[22m() function works just like the [1mstrtol[22m() function but returns a [4mlong[24m [4mlong[24m integer value.

[1mRETURN VALUE[0m
       The [1mstrtol[22m() function returns the result of the conversion, unless the value would underflow or overflow.  If an underflow occurs, [1mstrtol[22m() returns [1mLONG_MIN[22m.  If an overflow occurs, [1mstrtol[22m() returns [1mLONG_MAX[22m.  In both cases, [4merrno[24m is set to [1mERANGE[22m.  Precisely the same holds for [1mstrtoll[22m() (with [1mLLONG_MIN [22mand [1mLLONG_MAX [22minstead of [1mLONG_MIN [22mand [1mLONG_MAX[22m).

[1mERRORS[0m
       This function does not modify [4merrno[24m on success.

       [1mEINVAL [22m(not in C99) The given [4mbase[24m contains an unsupported value.

       [1mERANGE [22mThe resulting value was out of range.

       The implementation may also set [4merrno[24m to [1mEINVAL [22min case no conversion was performed (no digits seen, and 0 returned).

[1mATTRIBUTES[0m
       For an explanation of the terms used in this section, see [1mattributes[22m(7).
       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬───────────────┬────────────────┐
       │ [1mInterface                                                                                                                                                                                                                                                                                                                        [22m│ [1mAttribute     [22m│ [1mValue          [22m│
       ├──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼───────────────┼────────────────┤
       │ [1mstrtol[22m(), [1mstrtoll[22m(), [1mstrtoq[22m()                                                                                                                                                                                                                                                                                                    │ Thread safety │ MT-Safe locale │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴───────────────┴────────────────┘

[1mVERSIONS[0m
       According to POSIX.1, in locales other than "C" and "POSIX", these functions may accept other, implementation-defined numeric strings.

       BSD also has

           [1mquad_t strtoq(const char *[4m[22mnptr[24m[1m, char **[4m[22mendptr[24m[1m, int [4m[22mbase[24m[1m);[0m

       with completely analogous definition.  Depending on the wordsize of the current architecture, this may be equivalent to [1mstrtoll[22m() or to [1mstrtol[22m().

[1mSTANDARDS[0m
       C11, POSIX.1-2008.

[1mHISTORY[0m
       [1mstrtol[22m()
              POSIX.1-2001, C89, SVr4, 4.3BSD.

       [1mstrtoll[22m()
              POSIX.1-2001, C99.

[1mCAVEATS[0m
       Since [1mstrtol[22m() can legitimately return 0, [1mLONG_MAX[22m, or [1mLONG_MIN [22m([1mLLONG_MAX [22mor [1mLLONG_MIN [22mfor [1mstrtoll[22m()) on both success and failure, the calling program should set [4merrno[24m to 0 before the call, and then determine if an error occurred by checking whether [4merrno[24m [4m==[24m [4mERANGE[24m after the call.

       If the [4mbase[24m needs to be tested, it should be tested in a call where the string is known to succeed.  Otherwise, it's impossible to portably differentiate the errors.

           errno = 0;
           strtol("0", NULL, base);
           if (errno == EINVAL)
               goto unsupported_base;

[1mEXAMPLES[0m
       The program shown below demonstrates the use of [1mstrtol[22m().  The first command-line argument specifies a string from which [1mstrtol[22m() should parse a number.  The second (optional) argument specifies the base to be used for the conversion.  (This argument is converted to numeric form using [1matoi[22m(3), a function that performs no error checking and has  a  simpler
       interface than [1mstrtol[22m().)  Some examples of the results produced by this program are the following:

           $ [1m./a.out 123[0m
           strtol() returned 123
           $ [1m./a.out '    123'[0m
           strtol() returned 123
           $ [1m./a.out 123abc[0m
           strtol() returned 123
           Further characters after number: "abc"
           $ [1m./a.out 123abc 55[0m
           strtol: Invalid argument
           $ [1m./a.out ''[0m
           No digits were found
           $ [1m./a.out 4000000000[0m
           strtol: Numerical result out of range

   [1mProgram source[0m

       #include <errno.h>
       #include <stdio.h>
       #include <stdlib.h>

       int
       main(int argc, char *argv[])
       {
           int base;
           char *endptr, *str;
           long val;

           if (argc < 2) {
               fprintf(stderr, "Usage: %s str [base]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           str = argv[1];
           base = (argc > 2) ? atoi(argv[2]) : 0;

           errno = 0;    /* To distinguish success/failure after call */
           strtol("0", NULL, base);
           if (errno == EINVAL) {
               perror("strtol");
               exit(EXIT_FAILURE);
           }

           errno = 0;    /* To distinguish success/failure after call */
           val = strtol(str, &endptr, base);

           /* Check for various possible errors. */

           if (errno == ERANGE) {
               perror("strtol");
               exit(EXIT_FAILURE);
           }

           if (endptr == str) {
               fprintf(stderr, "No digits were found\n");
               exit(EXIT_FAILURE);
           }

           /* If we got here, strtol() successfully parsed a number. */

           printf("strtol() returned %ld\n", val);

           if (*endptr != '\0')        /* Not necessarily an error... */
               printf("Further characters after number: \"%s\"\n", endptr);

           exit(EXIT_SUCCESS);
       }

[1mSEE ALSO[0m
       [1matof[22m(3), [1matoi[22m(3), [1matol[22m(3), [1mstrtod[22m(3), [1mstrtoimax[22m(3), [1mstrtoul[22m(3)

Linux man-pages 6.9.1                                                                                                                                                            2024-06-16                                                                                                                                                                        [4mstrtol[24m(3)
